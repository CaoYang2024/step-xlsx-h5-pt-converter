"""
STEP/STP → Surface Mesh (via gmsh) → Export:
- pos:        (N,3) float32           Vertex coordinates (consistent with topology, no deduplication)
- edges:      (E,2) int64   [optional] Line elements (if generated by gmsh)
- faces_tri:  (T,3) int64   [optional] Triangular faces
- faces_quad: (Q,4) int64   [optional] Quadrilateral faces
- pos_down:   (M,3) float32 [optional] Randomly downsampled points (points only, no topology)
- normals:    (T,3) float32 [optional] Triangle face normals (if --normals is enabled)

Examples:
  python transform.py part.step out.pt --lc 1.5 --target_points 80000
  python transform.py part.stp  out.h5 --lc 2.0 --normals
"""

from __future__ import annotations
import argparse
import os
from typing import Dict, Any, Tuple, Optional

import numpy as np

# Optional dependencies
try:
    import torch
except Exception:
    torch = None
try:
    import h5py
except Exception:
    h5py = None

import gmsh


# ----------------------------- Core: Single meshing, preserve topology -----------------------------

def mesh_step_to_mesh(step_path: str, lc: float = 2.0) -> Dict[str, np.ndarray]:
    """
    Mesh a STEP surface using gmsh and return:
      - pos:       (N,3) float32
      - edges:     (E,2) int64 (may be empty)
      - faces_tri: (T,3) int64 (may be empty)
      - faces_quad:(Q,4) int64 (may be empty)

    Note: Keep gmsh’s node order (no geometric deduplication) to ensure topology consistency.
    """
    gmsh.initialize([])
    try:
        gmsh.option.setNumber("General.Terminal", 1)  # Run without GUI
        gmsh.model.add("step2mesh")

        # Import geometry
        gmsh.model.occ.importShapes(step_path)
        gmsh.model.occ.synchronize()

        # Meshing parameters (Frontal-Delaunay). Smaller lc → denser mesh
        gmsh.option.setNumber("Mesh.Algorithm", 6)  # 6 = Frontal-Delaunay
        gmsh.option.setNumber("Mesh.CharacteristicLengthMin", lc)
        gmsh.option.setNumber("Mesh.CharacteristicLengthMax", lc)
        # Optional: enable curvature-based refinement
        # gmsh.option.setNumber("Mesh.MeshSizeFromCurvature", 1)

        # Generate 2D surface mesh only
        gmsh.model.mesh.generate(2)

        # Nodes and elements (keep gmsh numbering)
        node_tags, node_coords, _ = gmsh.model.mesh.getNodes()
        pos = np.asarray(node_coords, dtype=np.float64).reshape(-1, 3).astype(np.float32)

        element_types, element_tags, node_tags_elem = gmsh.model.mesh.getElements()
    finally:
        gmsh.finalize()

    # Efficient tag (1-based) → index (0-based) mapping
    node_tags = np.asarray(node_tags, dtype=np.int64)
    if node_tags.size == 0:
        raise RuntimeError("No nodes were generated; try reducing --lc or check if the STEP file has valid surfaces.")
    max_tag = int(node_tags.max())
    lut = np.full(max_tag + 1, -1, dtype=np.int64)
    lut[node_tags] = np.arange(node_tags.shape[0], dtype=np.int64)

    edges = None
    faces_tri = None
    faces_quad = None

    for etype, elem_nodes in zip(element_types, node_tags_elem):
        arr = np.asarray(elem_nodes, dtype=np.int64)
        if etype == 1:  # 2-node line
            if arr.size >= 2:
                e = arr.reshape(-1, 2)
                e = lut[e]
                edges = e if edges is None else np.vstack([edges, e])
        elif etype == 2:  # 3-node triangle
            if arr.size >= 3:
                f3 = arr.reshape(-1, 3)
                f3 = lut[f3]
                faces_tri = f3 if faces_tri is None else np.vstack([faces_tri, f3])
        elif etype == 3:  # 4-node quadrilateral
            if arr.size >= 4:
                f4 = arr.reshape(-1, 4)
                f4 = lut[f4]
                faces_quad = f4 if faces_quad is None else np.vstack([faces_quad, f4])
        # Other element types (e.g., tetrahedra) are ignored; we only mesh surfaces

    data: Dict[str, np.ndarray] = {"pos": pos}
    if edges is not None:
        data["edges"] = edges.astype(np.int64, copy=False)
    if faces_tri is not None:
        data["faces_tri"] = faces_tri.astype(np.int64, copy=False)
    if faces_quad is not None:
        data["faces_quad"] = faces_quad.astype(np.int64, copy=False)
    return data


# ----------------------------- Optional: Triangle face normals -----------------------------

def compute_face_normals(pos: np.ndarray, faces_tri: np.ndarray) -> np.ndarray:
    """
    Compute normalized face normals for triangular faces.
    pos: (N,3) float32
    faces_tri: (T,3) int64
    return: (T,3) float32
    """
    v0 = pos[faces_tri[:, 0]]
    v1 = pos[faces_tri[:, 1]]
    v2 = pos[faces_tri[:, 2]]
    n = np.cross(v1 - v0, v2 - v0)  # (T,3)
    norm = np.linalg.norm(n, axis=1, keepdims=True) + 1e-12
    n = (n / norm).astype(np.float32)
    return n


# ----------------------------- Utility: Random downsampling (points only) -----------------------------

def random_downsample(points: np.ndarray, target: int, seed: int | None = None) -> np.ndarray:
    """Randomly downsample a point set to the target size (if larger)."""
    if target and points.shape[0] > target:
        rng = np.random.default_rng(seed)
        idx = rng.choice(points.shape[0], size=target, replace=False)
        return points[idx]
    return points


# ----------------------------- Saving -----------------------------

def save_pt(data: Dict[str, Any], out_path: str):
    if torch is None:
        raise RuntimeError("torch is required to save .pt files. Please install it with pip install torch")
    out = {}
    for k, v in data.items():
        if isinstance(v, np.ndarray):
            if v.dtype.kind in ("f",):      # float
                out[k] = torch.from_numpy(v.astype(np.float32, copy=False))
            elif v.dtype.kind in ("i", "u"):  # integer
                out[k] = torch.from_numpy(v.astype(np.int64, copy=False))
            else:
                raise TypeError(f"Unsupported dtype for field {k}: {v.dtype}")
        else:
            raise TypeError(f"Unsupported field type {k}: {type(v)}")
    torch.save(out, out_path)


def save_h5(data: Dict[str, Any], out_path: str):
    if h5py is None:
        raise RuntimeError("h5py is required to save .h5 files. Please install it with pip install h5py")
    with h5py.File(out_path, "w") as f:
        for k, v in data.items():
            f.create_dataset(k, data=v, compression="gzip")
        f.attrs["source"] = "STEP via Gmsh surface mesh"
        f.attrs["unit"] = "CAD native"


# ----------------------------- CLI -----------------------------

def main():
    ap = argparse.ArgumentParser(description="STEP/STP → Surface mesh → Export pos/edges/faces to .pt or .h5")
    ap.add_argument("input", help="Input STEP/STP file")
    ap.add_argument("output", help="Output .pt or .h5 file")
    ap.add_argument("--lc", type=float, default=2.0, help="Characteristic length (smaller = denser mesh), default=2.0")
    ap.add_argument("--target_points", type=int, default=0, help=">0: also save a downsampled point set as pos_down")
    ap.add_argument("--seed", type=int, default=None, help="Random seed for downsampling (reproducibility)")
    ap.add_argument("--normals", action="store_true", help="If triangular faces exist, compute unit normals")
    args = ap.parse_args()

    ext = os.path.splitext(args.output)[1].lower()
    if ext not in (".pt", ".h5"):
        raise SystemExit("Output file extension must be .pt or .h5")

    if not os.path.isfile(args.input):
        raise SystemExit(f"Input file does not exist: {args.input}")

    print(f"[info] meshing: {args.input}  lc={args.lc}")
    data = mesh_step_to_mesh(args.input, lc=args.lc)

    # Optional: face normals
    if args.normals and ("faces_tri" in data) and data["faces_tri"].size > 0:
        print("[info] computing triangle face normals")
        data["normals"] = compute_face_normals(data["pos"], data["faces_tri"])

    # Optional: random downsampling
    if args.target_points > 0:
        print(f"[info] downsampling pos to {args.target_points} (topology not changed)")
        data["pos_down"] = random_downsample(data["pos"], args.target_points, seed=args.seed).astype(np.float32)

    os.makedirs(os.path.dirname(os.path.abspath(args.output)) or ".", exist_ok=True)

    if ext == ".pt":
        save_pt(data, args.output)
    else:
        save_h5(data, args.output)

    # Summary report
    n_pos = data["pos"].shape[0]
    n_edges = data.get("edges", np.zeros((0, 2), dtype=np.int64)).shape[0]
    n_f3 = data.get("faces_tri", np.zeros((0, 3), dtype=np.int64)).shape[0]
    n_f4 = data.get("faces_quad", np.zeros((0, 4), dtype=np.int64)).shape[0]
    n_pos_down = data.get("pos_down", np.zeros((0, 3), dtype=np.float32)).shape[0]
    n_normals = data.get("normals", np.zeros((0, 3), dtype=np.float32)).shape[0]
    print(f"[done] {args.output}")
    print(f"       pos={n_pos}, edges={n_edges}, faces_tri={n_f3}, faces_quad={n_f4}"
          f"{', pos_down='+str(n_pos_down) if n_pos_down>0 else ''}"
          f"{', normals='+str(n_normals) if n_normals>0 else ''}")


if __name__ == "__main__":
    main()
